#include <vector>
using std::vector;
#include <iostream>
using std::cout;
using std::endl;
#include <algorithm>
using std::min;

#include "build.hpp"

using Bridge = vector<int>;
using myBridge = vector<int>;

enum
{
    west = 0,
    east = 1,
    toll = 2,
    status = 3
};

enum Status : int
{
    Buildable = 0,
    Built = 1,
    CannotBuild = 2
};

void printAllNodes(vector<myBridge> &allnodes)
{
    for (auto n : allnodes)
    {
        for (auto m : n)
        {
            cout << m << " ";
        }
        cout << endl;
    }
    cout << endl;
}

void printList(vector<vector<int>> &allnodes)
{
    for (auto n : allnodes)
    {
        cout << "{";
        for (auto m : n)
        {
            cout << " " << m << " ";
        }
        cout << "}" << endl;
    }
}

void printBridge(int index, vector<Bridge> &bridge)
{
    cout << "(" << bridge[index][west] << "," << bridge[index][east] << ")" << endl;
}

vector<int> getBuildableBridges(vector<myBridge> &bridges)
{
    vector<int> CanBuildCollection;
    for (int BridgeToBuildIndex = 0; BridgeToBuildIndex < bridges.size(); ++BridgeToBuildIndex)
    {
        if (bridges[BridgeToBuildIndex][status] == Status::Buildable)
        {
            bool buildableFlag = true;
            for (int BuiltBridgeIndex = 0; BuiltBridgeIndex < bridges.size(); ++BuiltBridgeIndex)
            {
                if (bridges[BuiltBridgeIndex][status] == Status::Built)
                {
                    int BuiltCityWest = bridges[BuiltBridgeIndex][west];
                    int BuiltCityEast = bridges[BuiltBridgeIndex][east];

                    int ToBuildWest = bridges[BridgeToBuildIndex][west];
                    int ToBuildEast = bridges[BridgeToBuildIndex][east];

                    if ((BuiltCityWest < ToBuildWest && BuiltCityEast > ToBuildEast) ||
                        (BuiltCityWest > ToBuildWest && BuiltCityEast < ToBuildEast) ||
                        (BuiltCityWest == ToBuildWest || BuiltCityEast == ToBuildEast))
                    {
                        bridges[BridgeToBuildIndex][status] = Status::CannotBuild;
                        buildableFlag = false;
                        break;
                    }
                }
            }
            if (buildableFlag)
            {
                CanBuildCollection.push_back(BridgeToBuildIndex);
            }
        }
    }
    return CanBuildCollection;
}

vector<Bridge> getState(vector<myBridge> &bridges)
{
    vector<Bridge> copy = bridges;
    return copy;
}

// YES time complexity
//  -getBuildableBridges
//  -push_back
//  -pop_back

//  -adjacencyList(not reserved) & listStarter (reserved)
void setMaxToll(vector<myBridge> &bridges,
                int &maxToll,
                vector<int> &listStarter,
                int listIndexer,
                int maxBridgeCount)
{
    auto canBuild = getBuildableBridges(bridges);

    if (canBuild.size() == 0 || listIndexer == maxBridgeCount)
    {
        int tollSum = 0;
        for (auto bridgeID : listStarter)
        {
            tollSum += bridges[bridgeID][toll];
        }

        if (tollSum > maxToll)
        {
            maxToll = tollSum;
        }
        listStarter.pop_back();
        return;
    }

    auto previousState = getState(bridges);
    for (int i = 0; i < canBuild.size(); ++i)
    {
        bridges = previousState;
        if (i > 0)
        {
            bridges[canBuild[i - 1]][status] = Status::CannotBuild;
        }
        bridges[canBuild[i]][status] = Status::Built;
        listStarter.push_back(canBuild[i]);
        setMaxToll(bridges, maxToll, listStarter, listIndexer, maxBridgeCount);
    }
    listStarter.pop_back();
    return;
}

void setAdjacencyList(vector<myBridge> &bridges,
                      vector<vector<int>> &adjacencyList,
                      vector<int> &listStarter)
{
    auto canBuild = getBuildableBridges(bridges);
    printAllNodes(bridges);

    if (canBuild.size() == 0)
    {
        adjacencyList.push_back(listStarter);
        listStarter.pop_back();
        return;
    }

    auto previousState = getState(bridges);
    for (int i = 0; i < canBuild.size(); ++i)
    {
        bridges = previousState; // this resets cannotbuild generated by getBUildable,
        // and builts generated by getBuildable
        if (i > 0)
        {
            bridges[canBuild[i - 1]][status] = Status::CannotBuild;
        }
        printAllNodes(bridges);

        bridges[canBuild[i]][status] = Status::Built;
        listStarter.push_back(canBuild[i]);
        setAdjacencyList(bridges, adjacencyList, listStarter);
    }
    listStarter.pop_back();
    return;
}

// no time complexity -- happens once
int getMaxTollPrice(vector<vector<int>> adjacencyList, const vector<Bridge> &bridges)
{

    int maxToll = 0;
    for (auto &allBuiltBridges : adjacencyList)
    {
        int totalToll = 0;
        for (auto &singleBuiltBridgeIndex : allBuiltBridges)
        {
            totalToll += bridges[singleBuiltBridgeIndex][toll];
        }
        if (totalToll > maxToll)
        {
            maxToll = totalToll;
        }
    }
    return maxToll;
}

// no time complexity -- happens once
vector<myBridge> translateToMyBridgeType(const vector<Bridge> &bridges)
{
    auto copy = bridges;
    for (auto &n : copy)
    {
        n.push_back(Status::Buildable);
    }
    return copy;
}

// no time complexity in of itself -- master function
int build(int w, int e, const vector<Bridge> &bridges)
{
    int maxBridgeCount = min(w, e);
    vector<myBridge> myBridges = translateToMyBridgeType(bridges);
    vector<int> listStarter{};
    listStarter.reserve(maxBridgeCount);
    int listIndexer = 0;
    int maxToll = 0;
    setMaxToll(myBridges, maxToll, listStarter, listIndexer, maxBridgeCount);
    return maxToll;
}

int buildAdjacency(int w, int e, const vector<Bridge> &bridges)
{
    int maxBridgeCount = min(w, e);
    vector<myBridge> myBridges = translateToMyBridgeType(bridges);
    vector<vector<int>> adjacencyList{};
    vector<int> listStarter{};
    listStarter.reserve(maxBridgeCount);
    int listIndexer = 0;
    int maxToll = 0;
    setAdjacencyList(myBridges, adjacencyList, listStarter);
    printList(adjacencyList);
    return getMaxTollPrice(adjacencyList, bridges);
}

// int main()
// {
//     int w = 5;
//     int e = 5;
//     const vector<Bridge> allNodes{
//         Bridge{0, 1, 3}, //0
//         Bridge{1, 1, 5}, //1
//         Bridge{1, 2, 4}, //2
//         Bridge{2, 0, 8}, //3
//         Bridge{2, 2, 6}, //4
//         Bridge{0, 0, 1}

//     }; // 5

//     int result = build(w, e, allNodes);
//     cout << result << endl;
//     return 0;
// }